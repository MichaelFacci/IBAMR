
IIMethod: mesh part 0 is using FIRST order LAGRANGE finite elements.


IIMethod: mesh part 1 is using FIRST order LAGRANGE finite elements.

IBHierarchyIntegrator::initializePatchHierarchy(): tag_buffer = 0
INSStaggeredHierarchyIntegrator::initializeCompositeHierarchyData():
  projecting the interpolated velocity field
INSStaggeredHierarchyIntegrator::regridProjection(): regrid projection solve number of iterations = 6
INSStaggeredHierarchyIntegrator::regridProjection(): regrid projection solve residual norm        = 1.00009e-12
Input database:
input_db {
   Re                             = 50                      // input used
   MU                             = 0.2                     // input used
   RHO                            = 1                       // input used
   L                              = 2                       // input used
   U_MAX                          = 2                       // input not used
   MAX_LEVELS                     = 1                       // input used
   REF_RATIO                      = 1                       // input used
   N                              = 128                     // input used
   NFINEST                        = 128                     // input used
   DX0                            = 0.015625                // input not used
   DX                             = 0.015625                // input used
   MFAC                           = 2                       // input used
   ELEM_TYPE                      = "TRI3"                  // input used
   elem_order                     = "FIRST"                 // input not used
   R                              = 0.75                    // input used
   Ro                             = 0.78125                 // input used
   B                              = 0                       // input not used
   OMEGA1                         = 0.000833                // input used
   OMEGA2                         = 0                       // input used
   PK1_DEV_QUAD_ORDER             = "SEVENTH"               // input not used
   PK1_DIL_QUAD_ORDER             = "FIFTH"                 // input not used
   USE_BOUNDARY_MESH              = TRUE                    // input not used
   CREEPING_FLOW                  = FALSE                   // input used
   IB_DELTA_FUNCTION              = "IB_3"                  // input used
   SPLIT_FORCES                   = TRUE                    // input used
   USE_PRESSURE_JUMP_CONDITIONS   = TRUE                    // input used
   USE_VELOCITY_JUMP_CONDITIONS   = TRUE                    // input used
   NORMALIZE_PRESSURE_JUMP        = TRUE                    // input used
   USE_CONSISTENT_MASS_MATRIX     = TRUE                    // input used
   WSS_CALC_WIDTH                 = 1.03                    // input used
   P_CALC_WIDTH                   = 1.2                     // input used
   IB_POINT_DENSITY               = 4                       // input used
   START_TIME                     = 0                       // input used
   END_TIME                       = 500                     // input used
   GROW_DT                        = 2                       // input used
   NUM_CYCLES                     = 1                       // input used
   CONVECTIVE_TS_TYPE             = "ADAMS_BASHFORTH"       // input used
   CONVECTIVE_OP_TYPE             = "STABILIZED_PPM"        // input used
   CONVECTIVE_FORM                = "ADVECTIVE"             // input used
   NORMALIZE_PRESSURE             = FALSE                   // input used
   CFL_MAX                        = 0.1                     // input used
   DT                             = 0.00015625              // input used
   ERROR_ON_DT_CHANGE             = TRUE                    // input used
   VORTICITY_TAGGING              = TRUE                    // input used
   TAG_BUFFER                     = 1                       // input used
   REGRID_CFL_INTERVAL            = 0.5                     // input used
   OUTPUT_U                       = TRUE                    // input used
   OUTPUT_P                       = TRUE                    // input used
   OUTPUT_F                       = TRUE                    // input used
   OUTPUT_OMEGA                   = TRUE                    // input used
   OUTPUT_DIV_U                   = TRUE                    // input used
   ENABLE_LOGGING                 = TRUE                    // input used
   e                              = 0.0234375               // input used
   c                              = 0.03125                 // input used
   eps                            = 0.75                    // input used
   SHIFT                          = 0                       // input used
   KAPPA_S                        = 8192                    // input used
   ETA_S                          = 0                       // input used
   USE_SECOND_VELOCITY_CORRECTION = TRUE                    // input used
   EXPLICITLY_REMOVE_NULLSPACE    = TRUE                    // input not used
   AA                             = -0.009792               // input used
   BB                             = 0.00597656              // input used
   U                              = "(sqrt(X0*X0 + X1*X1)< R ? -omega1*X1 : (sqrt((X0 - e)*(X0 - e) + X1*X1)> Ro ? 0.0 : -omega1*X1*(1.0 - (sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)) - (3*eps*((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)) - ((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)))*((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1))))*(2*X0/sqrt(X0*X0 + X1*X1)+3*eps+eps*eps*X0/sqrt(X0*X0 + X1*X1)))/((2+eps^2)*(1+eps*X0/sqrt(X0*X0 + X1*X1))))))" // input used
   V                              = "(sqrt(X0*X0 + X1*X1)< R ? omega1*X0 :  (sqrt((X0- e)*(X0 - e) + X1*X1)> Ro ? 0.0 : omega1*X0*(1.0 - (sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)) - (3*eps*((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)) - ((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)))*((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1))))*(2*X0/sqrt(X0*X0 + X1*X1)+3*eps+eps*eps*X0/sqrt(X0*X0 + X1*X1)))/((2+eps^2)*(1+eps*X0/sqrt(X0*X0 + X1*X1))))))" // input used
   P                              = "(sqrt(X0*X0 + X1*X1)< R ? 0.5*omega1*omega1*(X0*X0 + X1*X1) :  (sqrt((X0- e)*(X0 - e) + X1*X1)> Ro ? 0.0 : 6*MU*eps*omega1*R*R*(2.0 + eps*X0/sqrt(X0*X0 + X1*X1))*(X1/sqrt(X0*X0 + X1*X1))/((2+eps^2)*c*c*(1+eps*X0/sqrt(X0*X0 + X1*X1))*(1+eps*X0/sqrt(X0*X0 + X1*X1))) ))" // input used
   VelocityBcCoefs_0 {
      MU               = 0.2                                // input used
      R                = 0.75                               // input used
      Ro               = 0.78125                            // input used
      omega1           = 0.000833                           // input used
      omega2           = 0                                  // input used
      AA               = -0.009792                          // input used
      BB               = 0.00597656                         // input used
      e                = 0.0234375                          // input used
      c                = 0.03125                            // input used
      acoef_function_0 = "0.0"                              // input used
      acoef_function_1 = "0.0"                              // input used
      acoef_function_2 = "1.0"                              // input used
      acoef_function_3 = "1.0"                              // input used
      bcoef_function_0 = "1.0"                              // input used
      bcoef_function_1 = "1.0"                              // input used
      bcoef_function_2 = "0.0"                              // input used
      bcoef_function_3 = "0.0"                              // input used
      gcoef_function_0 = "0.0"                              // input used
      gcoef_function_1 = "0.0"                              // input used
      gcoef_function_2 = "0.0"                              // input used
      gcoef_function_3 = "0.0"                              // input used
   }
   VelocityBcCoefs_1 {
      R                = 0.75                               // input used
      Ro               = 0.78125                            // input used
      omega1           = 0.000833                           // input used
      omega2           = 0                                  // input used
      MU               = 0.2                                // input used
      AA               = -0.009792                          // input used
      BB               = 0.00597656                         // input used
      c                = 0.03125                            // input used
      eps              = 0.75                               // input used
      e                = 0.0234375                          // input used
      acoef_function_0 = "1.0"                              // input used
      acoef_function_1 = "1.0"                              // input used
      acoef_function_2 = "0.0"                              // input used
      acoef_function_3 = "0.0"                              // input used
      bcoef_function_0 = "0.0"                              // input used
      bcoef_function_1 = "0.0"                              // input used
      bcoef_function_2 = "1.0"                              // input used
      bcoef_function_3 = "1.0"                              // input used
      gcoef_function_0 = "0.0"                              // input used
      gcoef_function_1 = "0.0"                              // input used
      gcoef_function_2 = "0.0"                              // input used
      gcoef_function_3 = "0.0"                              // input used
   }
   VelocityInitialConditions {
      R          = 0.75                                     // input used
      Ro         = 0.78125                                  // input used
      omega1     = 0.000833                                 // input used
      omega2     = 0                                        // input used
      AA         = -0.009792                                // input used
      eps        = 0.75                                     // input used
      BB         = 0.00597656                               // input used
      e          = 0.0234375                                // input used
      c          = 0.03125                                  // input used
      function_0 = "(sqrt(X0*X0 + X1*X1)< R ? -omega1*X1 : (sqrt((X0 - e)*(X0 - e) + X1*X1)> Ro ? 0.0 : -omega1*X1*(1.0 - (sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)) - (3*eps*((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)) - ((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)))*((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1))))*(2*X0/sqrt(X0*X0 + X1*X1)+3*eps+eps*eps*X0/sqrt(X0*X0 + X1*X1)))/((2+eps^2)*(1+eps*X0/sqrt(X0*X0 + X1*X1))))))" // input used
      function_1 = "(sqrt(X0*X0 + X1*X1)< R ? omega1*X0 :  (sqrt((X0- e)*(X0 - e) + X1*X1)> Ro ? 0.0 : omega1*X0*(1.0 - (sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)) - (3*eps*((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)) - ((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1)))*((sqrt(X0*X0 + X1*X1) - R)/(c + e*X0/sqrt(X0*X0 + X1*X1))))*(2*X0/sqrt(X0*X0 + X1*X1)+3*eps+eps*eps*X0/sqrt(X0*X0 + X1*X1)))/((2+eps^2)*(1+eps*X0/sqrt(X0*X0 + X1*X1))))))" // input used
   }
   PressureInitialConditions {
      AA       = -0.009792                                  // input used
      eps      = 0.75                                       // input used
      BB       = 0.00597656                                 // input used
      e        = 0.0234375                                  // input used
      c        = 0.03125                                    // input used
      MU       = 0.2                                        // input used
      R        = 0.75                                       // input used
      Ro       = 0.78125                                    // input used
      omega1   = 0.000833                                   // input used
      omega2   = 0                                          // input used
      function = "(sqrt(X0*X0 + X1*X1)< R ? 0.5*omega1*omega1*(X0*X0 + X1*X1) :  (sqrt((X0- e)*(X0 - e) + X1*X1)> Ro ? 0.0 : 6*MU*eps*omega1*R*R*(2.0 + eps*X0/sqrt(X0*X0 + X1*X1))*(X1/sqrt(X0*X0 + X1*X1))/((2+eps^2)*c*c*(1+eps*X0/sqrt(X0*X0 + X1*X1))*(1+eps*X0/sqrt(X0*X0 + X1*X1))) ))" // input used
   }
   IBHierarchyIntegrator {
      start_time          = 0                               // input used
      end_time            = 500                             // input used
      grow_dt             = 2                               // input used
      num_cycles          = 1                               // input used
      regrid_cfl_interval = 0.5                             // input used
      dt_max              = 0.00015625                      // input used
      error_on_dt_change  = TRUE                            // input used
      enable_logging      = TRUE                            // input used
   }
   IIMethod {
      IB_delta_fcn                   = "IB_3"               // input used
      split_forces                   = TRUE                 // input not used
      use_pressure_jump_conditions   = TRUE                 // input used
      use_velocity_jump_conditions   = TRUE                 // input used
      use_consistent_mass_matrix     = TRUE                 // input used
      IB_point_density               = 4                    // input used
      wss_calc_width                 = 1.03                 // input used
      p_calc_width                   = 1.2                  // input not used
      min_ghost_cell_width           = 6                    // input used
      normalize_pressure_jump        = TRUE                 // input not used
      use_second_velocity_correction = TRUE                 // input used
   }
   INSStaggeredHierarchyIntegrator {
      mu                            = 0.2                   // input used
      rho                           = 1                     // input used
      start_time                    = 0                     // input used
      end_time                      = 500                   // input used
      creeping_flow                 = FALSE                 // input used
      grow_dt                       = 2                     // input used
      convective_time_stepping_type = "ADAMS_BASHFORTH"     // input used
      convective_op_type            = "STABILIZED_PPM"      // input used
      convective_difference_form    = "ADVECTIVE"           // input used
      normalize_pressure            = FALSE                 // input used
      cfl                           = 0.1                   // input used
      dt_max                        = 0.00015625            // input used
      using_vorticity_tagging       = TRUE                  // input used
      vorticity_rel_thresh          = 0.01                  // input used
      tag_buffer                    = 1                     // input used
      output_U                      = TRUE                  // input used
      output_P                      = TRUE                  // input used
      output_F                      = TRUE                  // input used
      output_Omega                  = TRUE                  // input used
      output_Div_U                  = TRUE                  // input used
      enable_logging                = TRUE                  // input used
      U_P_bdry_interp_type          = "LINEAR"              // from default
   }
   Main {
      log_file_name               = "II_2D_N_128_pbc_normjump.log" // input used
      log_all_nodes               = FALSE                   // input used
      viz_writer                  = "VisIt", "ExodusII"     // input used
      viz_dump_interval           = 50                      // input used
      viz_dump_dirname            = "viz_II_2D_N_128_pbc_normjump" // input used
      visit_number_procs_per_file = 1                       // input used
      restart_dump_interval       = 0                       // input used
      restart_dump_dirname        = "restart_IB2d"          // input used
      data_dump_interval          = 50                      // input used
      data_dump_dirname           = "hier_data_II2d_N_128_pbc_normjump" // input used
      timer_dump_interval         = 0                       // input used
   }
   CartesianGeometry {
      domain_boxes       = [(0,0),(127,127)]                // input used
      x_lo               = -1, -1                           // input used
      x_up               = 1, 1                             // input used
      periodic_dimension = 0, 0                             // input used
   }
   GriddingAlgorithm {
      max_levels                = 1                         // input used
      efficiency_tolerance      = 0.85                      // input used
      combine_efficiency        = 0.85                      // input used
      check_nonrefined_tags     = 'w'                       // from default
      check_overlapping_patches = 'i'                       // from default
      extend_tags_to_bdry       = FALSE                     // from default
      ratio_to_coarser {
         level_1 = 1, 1                                     // input not used
         level_2 = 1, 1                                     // input not used
         level_3 = 1, 1                                     // input not used
         level_4 = 1, 1                                     // input not used
         level_5 = 1, 1                                     // input not used
      }
      largest_patch_size {
         level_0 = 128, 128                                 // input used
      }
      smallest_patch_size {
         level_0 = 128, 128                                 // input used
      }
   }
   StandardTagAndInitialize {
      tagging_method = "GRADIENT_DETECTOR"                  // input used
   }
   LoadBalancer {
      bin_pack_method                      = "SPATIAL"      // input used
      max_workload_factor                  = 1              // input used
      ignore_level_box_union_is_single_box = FALSE          // from default
   }
   TimerManager {
      print_exclusive      = FALSE                          // input used
      print_total          = TRUE                           // input used
      print_threshold      = 0.1                            // input used
      timer_list           = "IBAMR::*::*", "IBTK::*::*", "*::*::*" // input used
      print_processor      = TRUE                           // from default
      print_max            = FALSE                          // from default
      print_summed         = FALSE                          // from default
      print_user           = FALSE                          // from default
      print_sys            = FALSE                          // from default
      print_wall           = TRUE                           // from default
      print_percentage     = TRUE                           // from default
      print_concurrent     = FALSE                          // from default
      print_timer_overhead = FALSE                          // from default
   }
}


Writing visualization files...


+++++++++++++++++++++++++++++++++++++++++++++++++++
At beginning of timestep # 0
Simulation time is 0
IBHierarchyIntegrator::advanceHierarchy(): time interval = [0,0.00015625], dt = 0.00015625
IBHierarchyIntegrator::advanceHierarchy(): regridding prior to timestep 0
IBHierarchyIntegrator::regridHierarchy(): starting Lagrangian data movement
IBHierarchyIntegrator::regridHierarchy(): regridding the patch hierarchy
IBHierarchyIntegrator::regridHierarchy(): finishing Lagrangian data movement
INSStaggeredHierarchyIntegrator::preprocessIntegrateHierarchy(): initializing convective operator
INSStaggeredHierarchyIntegrator::preprocessIntegrateHierarchy(): initializing velocity subdomain solver
INSStaggeredHierarchyIntegrator::preprocessIntegrateHierarchy(): initializing pressure subdomain solver
INSStaggeredHierarchyIntegrator::preprocessIntegrateHierarchy(): initializing incompressible Stokes solver
IBHierarchyIntegrator::preprocessIntegrateHierarchy(): performing Lagrangian forward Euler step
IBHierarchyIntegrator::advanceHierarchy(): integrating hierarchy
IBHierarchyIntegrator::integrateHierarchy(): computing Lagrangian force
IBHierarchyIntegrator::integrateHierarchy(): spreading Lagrangian force to the Eulerian grid
IBHierarchyIntegrator::integrateHierarchy(): solving the incompressible Navier-Stokes equations
INSStaggeredHierarchyIntegrator::integrateHierarchy(): stokes solve number of iterations = 3
INSStaggeredHierarchyIntegrator::integrateHierarchy(): stokes solve residual norm        = 3.80941e-06
INSStaggeredHierarchyIntegrator::integrateHierarchy(): stokes solve number of iterations = 0
INSStaggeredHierarchyIntegrator::integrateHierarchy(): stokes solve residual norm        = 3.84852e-06
IBHierarchyIntegrator::integrateHierarchy(): interpolating Eulerian velocity to the Lagrangian mesh
